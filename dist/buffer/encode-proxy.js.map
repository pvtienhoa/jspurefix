{"version":3,"file":"encode-proxy.js","sourceRoot":"","sources":["../../src/buffer/encode-proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { FixDefinitions, MessageDefinition, SimpleFieldDefinition, ContainedField, ContainedFieldType, ContainedSimpleField, ContainedComponentField, ContainedGroupField, ContainedFieldSet } from '../dictionary'\r\nimport { ILooseObject } from '../collections/collection'\r\nimport { TagType } from './tags'\r\n\r\nexport class EncodeProxy {\r\n  constructor (public readonly definitions: FixDefinitions) {\r\n  }\r\n\r\n  private static SimpleFieldCheck (field: ContainedSimpleField, val: any): void {\r\n    const sf: ContainedSimpleField = field as ContainedSimpleField\r\n    const definition: SimpleFieldDefinition = sf.definition\r\n    if (definition.isEnum()) {\r\n      const resolved: boolean = definition.containsEnum(val)\r\n      if (!resolved) {\r\n        throw new Error(`enum field ${field.name} does not support \"${val}\"`)\r\n      }\r\n    }\r\n    switch (definition.tagType) {\r\n      case TagType.LocalDate:\r\n      case TagType.UtcTimeOnly:\r\n      case TagType.UtcDateOnly:\r\n      case TagType.UtcTimestamp: {\r\n        const isDate: boolean = val instanceof Date\r\n        if (!isDate) {\r\n          throw new Error(`field ${field.name} expects Date but receives \"${typeof val}\"`)\r\n        }\r\n        break\r\n      }\r\n\r\n      case TagType.Boolean: {\r\n        if (typeof(val) !== typeof(true)) {\r\n          throw new Error(`field ${field.name} expects boolean but receives \"${typeof val}\"`)\r\n        }\r\n        break\r\n      }\r\n\r\n      case TagType.String: {\r\n        if (typeof(val) !== 'string') {\r\n          throw new Error(`field ${field.name} expects string but receives \"${typeof val}\"`)\r\n        }\r\n        break\r\n      }\r\n\r\n      case TagType.RawData: {\r\n        const isBuffer: boolean = val instanceof Buffer\r\n        if (!isBuffer) {\r\n          throw new Error(`field ${field.name} expects Buffer but receives \"${typeof val}\"`)\r\n        }\r\n        break\r\n      }\r\n\r\n      case TagType.Int:\r\n      case TagType.Float:\r\n      case TagType.Length: {\r\n        if (isNaN(val)) {\r\n          throw new Error(`field ${field.name} expects number but receives \"${typeof val}\"`)\r\n        }\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  private static checkProperties (wrapped: ILooseObject, val: ILooseObject): ILooseObject {\r\n    const keys: string[] = Object.keys(val)\r\n    for (let k of keys) {\r\n      wrapped[k] = val[k]\r\n    }\r\n    return wrapped\r\n  }\r\n\r\n  private static ComponentFieldCheck (field: ContainedComponentField, val: any): object {\r\n    const isComplex: boolean = typeof val === 'object'\r\n    if (!isComplex) {\r\n      throw new Error(`type ${field.name} is a component but is given type \"${typeof val}\"`)\r\n    }\r\n    const cf: ContainedComponentField = field as ContainedComponentField\r\n    return EncodeProxy.checkProperties(new Proxy({}, EncodeProxy.handler(cf.definition)), val)\r\n  }\r\n\r\n  private static GroupFieldCheck (field: ContainedGroupField, val: any): object {\r\n    const accepted: boolean = Array.isArray(val) || !isNaN(val)\r\n    if (!accepted) {\r\n      throw new Error(`type ${field.name} is a group and needs array or number, not \"${typeof val}\"`)\r\n    }\r\n    const gf: ContainedComponentField = field as ContainedComponentField\r\n    const j: number = val\r\n    const isNumber: boolean = !isNaN(val)\r\n    if (isNumber) {\r\n      const arr: ILooseObject[] = new Array(j)\r\n      for (let i: number = 0; i < j; ++i) {\r\n        arr[i] = new Proxy({}, EncodeProxy.handler(gf.definition))\r\n      }\r\n      return arr\r\n    } else {\r\n      const arr: ILooseObject[] = val\r\n      for (let i: number = 0; i < arr.length; ++i) {\r\n        arr[i] = EncodeProxy.checkProperties(new Proxy({}, EncodeProxy.handler(gf.definition)), arr[i])\r\n      }\r\n      return arr\r\n    }\r\n  }\r\n\r\n  private static handler (set: ContainedFieldSet): Object {\r\n    return {\r\n      set (target: ILooseObject, prop: string, val: any): boolean {\r\n        const field: ContainedField = set.localNameToField.get(prop)\r\n        if (!field) {\r\n          throw new Error(`type ${set.name} has no field named ${prop}`)\r\n        }\r\n        target[prop] = EncodeProxy.examine(field, val)\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  private static examine (field: ContainedField, val: any): any {\r\n    switch (field.type) {\r\n      case ContainedFieldType.Simple: {\r\n        EncodeProxy.SimpleFieldCheck(field as ContainedSimpleField, val)\r\n        break\r\n      }\r\n\r\n      case ContainedFieldType.Component: {\r\n        val = EncodeProxy.ComponentFieldCheck(field as ContainedComponentField, val)\r\n        break\r\n      }\r\n\r\n      case ContainedFieldType.Group: {\r\n        val = EncodeProxy.GroupFieldCheck(field as ContainedGroupField, val)\r\n        break\r\n      }\r\n    }\r\n    return val\r\n  }\r\n  public wrap (msgName: string): ILooseObject {\r\n    const msg: MessageDefinition = this.definitions.message.get(msgName)\r\n    if (!msg) {\r\n      throw new Error(`no message defined for type ${msgName}`)\r\n    }\r\n\r\n    return new Proxy({}, EncodeProxy.handler(msg))\r\n  }\r\n}\r\n"]}