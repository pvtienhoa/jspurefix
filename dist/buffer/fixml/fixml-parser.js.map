{"version":3,"file":"fixml-parser.js","sourceRoot":"","sources":["../../../src/buffer/fixml/fixml-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { MsgParser } from '../msg-parser'\r\nimport { Tags } from '../tags'\r\nimport { ContainedField, ContainedFieldType, ContainedComponentField, ContainedGroupField, ContainedSimpleField, ContainedFieldSet, ISaxNode, SAXStream, FixDefinitions, MessageDefinition } from '../../dictionary'\r\nimport { SegmentDescription, SegmentType } from '../segment-description'\r\nimport { IJsFixConfig, IJsFixLogger } from '../../config'\r\nimport { MsgView } from '../msg-view'\r\nimport { Structure } from '../structure'\r\nimport { FixmlView } from './fixml-view'\r\nimport { Readable } from 'stream'\r\n\r\nexport class FiXmlParser extends MsgParser {\r\n  private readonly locations: Tags\r\n  private values: string[] = []\r\n  private readonly saxStream: SAXStream\r\n  private readonly definitions: FixDefinitions\r\n  private readonly segments: SegmentDescription[] = []\r\n  private readonly segmentStack: SegmentDescription[] = []\r\n  private readonly logger: IJsFixLogger\r\n  private last: SegmentDescription\r\n  private raw: string\r\n  constructor (public readonly config: IJsFixConfig,\r\n               public readonly readStream: Readable,\r\n               public readonly maxMessageLocations: number = 10 * 1024) {\r\n    super()\r\n    this.definitions = this.config.definitions\r\n    const description = config.description\r\n    const me = description.application.name\r\n    this.logger = config.logFactory.logger(`${me}:FiXmlParser`)\r\n    this.saxStream = require('sax').createStream(true, {})\r\n    this.locations = new Tags(this.definitions, maxMessageLocations)\r\n    this.logger.info('subscribe to stream')\r\n    this.subscribe()\r\n  }\r\n\r\n  private reset (): void {\r\n    const segments = this.segments\r\n    while (segments.length > 0) {\r\n      segments.pop()\r\n    }\r\n    const stack = this.segmentStack\r\n    this.last = null\r\n    this.raw = null\r\n    this.values = []\r\n    this.locations.reset()\r\n    while (stack.length) {\r\n      stack.pop()\r\n    }\r\n  }\r\n\r\n  private subscribe (): void {\r\n    const writeStream = this.saxStream\r\n    const readStream = this.readStream\r\n    let instance = this\r\n    readStream.pipe(writeStream).on('ready', () => {\r\n      this.logger.info('stream close event')\r\n      this.emit('close')\r\n    })\r\n    readStream.on('error', (e) => {\r\n      this.logger.error(e)\r\n      this.emit('error', e)\r\n    })\r\n    readStream.on('end', () => {\r\n      this.logger.info('stream end event')\r\n      this.emit('end')\r\n    })\r\n    writeStream.on('data', (i: Buffer) => {\r\n      if (instance.last) {\r\n        instance.emit('decoded', instance.last.name, i.toString())\r\n      } else {\r\n        this.raw = i.toString()\r\n      }\r\n    })\r\n\r\n    writeStream.on('opentag', (node) => {\r\n      const stack = this.segmentStack\r\n      const saxNode: ISaxNode = node as ISaxNode\r\n      switch (saxNode.name) {\r\n        case 'FIXML':\r\n          this.reset()\r\n          break\r\n\r\n        case 'Batch': {\r\n          const locations = this.locations\r\n          const ptr = locations.nextTagPos - 1\r\n          const segment: SegmentDescription = new SegmentDescription(saxNode.name,\r\n            -1,\r\n            null,\r\n            ptr,\r\n            stack.length,\r\n            SegmentType.Batch)\r\n          segment.startPosition = 0\r\n          stack.push(segment)\r\n          break\r\n        }\r\n\r\n        case 'Hdr': {\r\n          this.hdr(saxNode)\r\n          break\r\n        }\r\n\r\n        default: {\r\n          const stack = this.segmentStack\r\n          const isBatch: boolean = stack.length === 1 && stack[0].type === SegmentType.Batch\r\n          const isMsg: boolean = stack.length === 0\r\n          if (isMsg) {\r\n            // one single message\r\n            this.msg(saxNode)\r\n          } else if (isBatch) {\r\n            // one message within a batch or it\r\n            this.msgInBatch(saxNode)\r\n          } else {\r\n            // or it is a structure within a message\r\n            this.element(saxNode)\r\n          }\r\n        }\r\n      }\r\n    })\r\n    writeStream.on('closetag', (name: string) => {\r\n      this.pop(name)\r\n    })\r\n    writeStream.on('error', (e: Error) => {\r\n      this.emit('error', e)\r\n    })\r\n  }\r\n\r\n  private hdr (saxNode: ISaxNode): void {\r\n    const stack = this.segmentStack\r\n    if (stack.length === 0) {\r\n      throw new Error(`Hdr not expected before batch or message ${saxNode.name}`)\r\n    }\r\n    let peek: SegmentDescription = stack[stack.length - 1]\r\n    switch (peek.type) {\r\n      case SegmentType.Batch: {\r\n        // manually handle this component\r\n        const hdr = this.definitions.component.get('StandardHeader')\r\n        const segment: SegmentDescription = this.parseAttributes(saxNode.name, hdr, saxNode, SegmentType.Component)\r\n        this.segmentStack.push(segment)\r\n        break\r\n      }\r\n\r\n      case SegmentType.Msg: {\r\n        this.element(saxNode)\r\n        break\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Hdr not expected before batch or message ${saxNode.name}`)\r\n    }\r\n  }\r\n\r\n  private msgInBatch (saxNode: ISaxNode): void {\r\n    this.logger.info(` ${saxNode.name}: start batch`)\r\n    const locations = this.locations\r\n    const batch = this.segmentStack[0]\r\n    const ptr = locations.nextTagPos\r\n    if (!batch.delimiterPositions) {\r\n      batch.startGroup(-1)\r\n    }\r\n    batch.addDelimiterPosition(ptr)\r\n    this.logger.debug(` ${saxNode.name}: begin parse msg ${batch.delimiterPositions.length} in batch`)\r\n    this.msg(saxNode, true)\r\n  }\r\n\r\n  private getView (): MsgView {\r\n    const structure: Structure = new Structure(this.locations, this.segments)\r\n    const last = structure.segments[structure.segments.length - 1]\r\n    return new FixmlView(last, this.values, structure)\r\n  }\r\n\r\n  private pop (name: string): SegmentDescription {\r\n    const locations = this.locations\r\n    const stack = this.segmentStack\r\n    const segments = this.segments\r\n    while (stack.length > 0) {\r\n      const pop = stack.pop()\r\n      const ptr = locations.nextTagPos - 1\r\n      pop.end(segments.length, ptr, locations.tagPos[ptr].tag)\r\n      segments[segments.length] = pop\r\n      switch (pop.type) {\r\n        case SegmentType.Msg: {\r\n          // raise msg event\r\n          const last = segments[segments.length - 1]\r\n          this.last = last\r\n          this.emit('msg', last.name, this.getView())\r\n          if (this.raw) {\r\n            this.emit('decoded', this.last.name, this.raw)\r\n            this.raw = null\r\n          }\r\n          break\r\n        }\r\n        case SegmentType.Batch: {\r\n          const last = segments[segments.length - 1]\r\n          this.logger.debug(`emit batch with ${pop.delimiterPositions.length} elements`)\r\n          this.emit('batch', last.set.abbreviation, this.getView())\r\n          break\r\n        }\r\n      }\r\n      if (pop.name === name) {\r\n        return pop\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  private startGroup (saxNode: ISaxNode, gf: ContainedGroupField) {\r\n    const locations = this.locations\r\n    const stack: SegmentDescription[] = this.segmentStack\r\n    const ptr = locations.nextTagPos\r\n    const def = gf.definition\r\n    const segment: SegmentDescription = this.parseAttributes(saxNode.name, def, saxNode, SegmentType.Component)\r\n    const group: SegmentDescription = new SegmentDescription(def.name,\r\n      locations.tagPos[ptr].tag,\r\n      def,\r\n      ptr,\r\n      stack.length,\r\n      SegmentType.Group)\r\n    group.startGroup(locations.tagPos[ptr].tag)\r\n    group.addDelimiterPosition(ptr)\r\n    stack.push(group)\r\n    stack.push(segment)\r\n  }\r\n\r\n  private getNextField (saxNode: ISaxNode): ContainedField {\r\n    const stack: SegmentDescription[] = this.segmentStack\r\n    while (stack.length > 0) {\r\n      let peek: SegmentDescription = stack[stack.length - 1]\r\n      let field = peek.set.localNameToField.get(saxNode.name)\r\n      if (field) {\r\n        return field\r\n      }\r\n      // if this is a group of the same type as already on stack\r\n      // take the field from the next level up\r\n      if (peek.type === SegmentType.Group && stack.length > 1) {\r\n        const contained = stack[stack.length - 2].set.localNameToField.get(saxNode.name)\r\n        if (contained instanceof ContainedGroupField) {\r\n          if (contained.definition.name === peek.name) {\r\n            // this is the same type for next instance in the same group.\r\n            return contained\r\n          }\r\n        }\r\n      }\r\n      // then have ended previous group. Pop and return to see if this field lives on the parent\r\n      const locations = this.locations\r\n      const ptr = locations.nextTagPos - 1\r\n      const pop = stack.pop()\r\n      const segments = this.segments\r\n      pop.end(segments.length, ptr, locations.tagPos[ptr].tag)\r\n      segments[segments.length] = pop\r\n    }\r\n    return null\r\n  }\r\n\r\n  private dispatch (saxNode: ISaxNode, field: ContainedField) {\r\n    switch (field.type) {\r\n      case ContainedFieldType.Component: {\r\n        const cf: ContainedComponentField = field as ContainedComponentField\r\n        const segment: SegmentDescription = this.parseAttributes(saxNode.name, cf.definition, saxNode, SegmentType.Component)\r\n        this.segmentStack.push(segment)\r\n        break\r\n      }\r\n\r\n      case ContainedFieldType.Group: {\r\n        this.dispatchGroup(saxNode, field as ContainedGroupField)\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  private dispatchGroup (saxNode: ISaxNode, gf: ContainedGroupField): void {\r\n    const stack: SegmentDescription[] = this.segmentStack\r\n    const peek: SegmentDescription = stack[stack.length - 1]\r\n    switch (peek.type) {\r\n      case SegmentType.Msg:\r\n      case SegmentType.Component: {\r\n        this.startGroup(saxNode, gf)\r\n        break\r\n      }\r\n\r\n      case SegmentType.Group: {\r\n        if (gf.name === saxNode.name) {\r\n          const ptr = this.locations.nextTagPos\r\n          peek.addDelimiterPosition(ptr)\r\n          stack[stack.length] = this.parseAttributes(saxNode.name, gf.definition, saxNode, SegmentType.Component)\r\n        } else {\r\n          throw new Error(`expected another group instance of ${gf.name} but got ${saxNode.name}`)\r\n        }\r\n        break\r\n      }\r\n\r\n      default:\r\n        throw new Error(`dispatchGroup has field ${gf.name} peek type ${peek.type}`)\r\n    }\r\n  }\r\n\r\n  private element (saxNode: ISaxNode): void {\r\n    // may terminate a group and move fields\r\n    const field = this.getNextField(saxNode)\r\n    if (!field) {\r\n      const stack: SegmentDescription[] = this.segmentStack\r\n      let peek: SegmentDescription = stack[stack.length - 1]\r\n      throw new Error(`field ${saxNode.name} not known in set ${peek.set.name}`)\r\n    }\r\n    this.dispatch(saxNode, field)\r\n  }\r\n\r\n  private msg (saxNode: ISaxNode, inBatch: boolean = false): void {\r\n    this.logger.debug(`${saxNode.name}: begin parse msg`)\r\n    const type: string = saxNode.name\r\n    const def: MessageDefinition = this.definitions.message.get(type)\r\n    if (!def) {\r\n      throw new Error(`unknown message type ${type}`)\r\n    }\r\n    if (inBatch) {\r\n      const batch = this.segmentStack[0]\r\n      batch.set = def\r\n    }\r\n    const segment: SegmentDescription = this.parseAttributes(type, def, saxNode, SegmentType.Msg)\r\n    this.segmentStack.push(segment)\r\n  }\r\n\r\n  private parseAttributes (name: string, set: ContainedFieldSet, saxNode: ISaxNode, type: SegmentType): SegmentDescription {\r\n    const locations = this.locations\r\n    const attributes = saxNode.attributes\r\n    const values = this.values\r\n    let ptr: number\r\n    if (attributes) {\r\n      const keys: string[] = Object.keys(attributes)\r\n      ptr = keys.length > 0 ? locations.nextTagPos : locations.nextTagPos - 1\r\n      for (let j: number = 0; j < keys.length; ++j) {\r\n        const k: string = keys[j]\r\n        const v: string = attributes[k]\r\n        const field: ContainedSimpleField = set.localNameToField.get(k) as ContainedSimpleField\r\n        if (!field) {\r\n          this.logger.warning(`no field ${k} in set ${set.name}`)\r\n          locations.store(j, 1, -1)\r\n        } else {\r\n          locations.store(j, 1, field.definition.tag)\r\n        }\r\n        values[values.length] = v\r\n      }\r\n      return new SegmentDescription(name, locations.tagPos[ptr].tag, set, ptr, this.segmentStack.length, type)\r\n    }\r\n  }\r\n}\r\n"]}