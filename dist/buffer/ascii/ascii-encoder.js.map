{"version":3,"file":"ascii-encoder.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-encoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { ILooseObject } from '../../collections/collection'\r\nimport { ContainedGroupField, ContainedSimpleField, ContainedFieldSet, ContainedField, ContainedFieldType, ContainedComponentField, SimpleFieldDefinition, FixDefinitions, dispatchFields } from '../../dictionary'\r\nimport { MsgEncoder } from '../msg-encoder'\r\nimport { ElasticBuffer } from '../elastic-buffer'\r\nimport { TimeFormatter } from './time-formatter'\r\nimport { ITimeFormatter } from './itime-formatter'\r\nimport { AsciiChars } from '../ascii-chars'\r\nimport { Tags, TagType } from '../tags'\r\n\r\nexport class AsciiEncoder extends MsgEncoder {\r\n\r\n  public bodyLengthPos: number\r\n\r\n  constructor (public readonly buffer: ElasticBuffer,\r\n               public readonly definitions: FixDefinitions,\r\n               public readonly timeFormatter: ITimeFormatter = new TimeFormatter(buffer),\r\n               public readonly delimiter: number = AsciiChars.Soh) {\r\n    super(definitions)\r\n  }\r\n\r\n  private static checkGroupInstanceHasDelimiter (gf: ContainedGroupField, instance: ILooseObject): boolean {\r\n    const delimiterField: ContainedSimpleField = gf.definition.firstSimple\r\n    if (!delimiterField) {\r\n      throw new Error(`group definition has delimiter field ${delimiterField.definition.name}`)\r\n    }\r\n    // may have a group represented by a component where first simple field is further down.\r\n    while (instance != null) {\r\n      if (instance[delimiterField.definition.name] != null) {\r\n        return true\r\n      }\r\n      const first = gf.definition.fields[0]\r\n      switch (first.type) {\r\n        case ContainedFieldType.Component: {\r\n          const cf: ContainedComponentField = first as ContainedComponentField\r\n          instance = instance[cf.definition.name]\r\n          break\r\n        }\r\n        default:\r\n          instance = null\r\n      }\r\n    }\r\n  }\r\n\r\n  public encodeSet (objectToEncode: ILooseObject, set: ContainedFieldSet): void {\r\n    const fields: ContainedField[] = this.getFields(set, objectToEncode)\r\n    dispatchFields(fields, {\r\n      simple: (sf: ContainedSimpleField) => {\r\n        const val: any = objectToEncode[sf.name]\r\n        if (val != null) {\r\n          this.encodeSimple(objectToEncode, set, sf, val)\r\n        }\r\n      },\r\n      component: (cf: ContainedComponentField) => {\r\n        const instance: ILooseObject = objectToEncode[cf.definition.name]\r\n        if (instance) {\r\n          this.encodeSet(instance, cf.definition)\r\n        }\r\n      },\r\n      group: (gf: ContainedGroupField) => {\r\n        this.encodeInstances(objectToEncode, gf)\r\n      }\r\n    })\r\n  }\r\n\r\n  private getFields (set: ContainedFieldSet, o: ILooseObject): ContainedField[] {\r\n    const keys: string[] = Object.keys(o)\r\n    let j: number = 0\r\n    const fields: ContainedField[] = keys.reduce((a: ContainedField[], current: string) => {\r\n      const field: ContainedField = set.localNameToField.get(current)\r\n      if (field) {\r\n        a[j++] = field\r\n      }\r\n      return a\r\n    }, new Array(keys.length))\r\n    fields.sort((a: ContainedField, b: ContainedField) => a.position - b.position)\r\n    return fields\r\n  }\r\n\r\n  private encodeInstances (o: ILooseObject, gf: ContainedGroupField): void {\r\n    const noOfField: SimpleFieldDefinition = gf.definition.noOfField\r\n    const instances: ILooseObject[] = o[gf.name] || o[noOfField.name]\r\n    const buffer = this.buffer\r\n    if (!Array.isArray(instances)) {\r\n      throw new Error(`expected array instance for group ${noOfField.name}`)\r\n    }\r\n    if (instances) {\r\n      // a repeated group has number of instances at the start of group\r\n      this.WriteTagEquals(noOfField.tag)\r\n      buffer.writeWholeNumber(instances.length)\r\n      buffer.writeChar(this.delimiter)\r\n      instances.forEach((i: ILooseObject) => {\r\n        if (AsciiEncoder.checkGroupInstanceHasDelimiter(gf, i)) {\r\n          this.encodeSet(i, gf.definition)\r\n        } else {\r\n          const delimiter: ContainedSimpleField = gf.definition.firstSimple\r\n          throw new Error(`group instance with no delimiter field ${delimiter.definition.name}`)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  private WriteTagEquals (tag: number): void {\r\n    const buffer = this.buffer\r\n    buffer.writeWholeNumber(tag)\r\n    buffer.writeChar(AsciiChars.Equal)\r\n  }\r\n\r\n  private encodeSimple (o: ILooseObject, set: ContainedFieldSet, sf: ContainedSimpleField, val: any): void {\r\n    const definition = sf.definition\r\n    const tag: number = definition.tag\r\n    const buffer = this.buffer\r\n    const delimiter = this.delimiter\r\n    const tf = this.timeFormatter\r\n    const pos = buffer.getPos()\r\n\r\n    let tagType: TagType\r\n    if (typeof val === 'string') {\r\n      switch (definition.tagType) {\r\n        case TagType.Boolean: {\r\n          tagType = definition.tagType\r\n          const vs: string = val\r\n          const first: string = vs.length > 0 ? vs.charAt(0) : 'N'\r\n          val = first === 'Y' || first === 'T'\r\n          break\r\n        }\r\n        default: {\r\n          tagType = TagType.String\r\n        }\r\n      }\r\n    } else {\r\n      tagType = definition.tagType\r\n    }\r\n\r\n    switch (tagType) {\r\n\r\n      case TagType.RawData: {\r\n        // may need to first write raw message length (see below)\r\n        break\r\n      }\r\n\r\n      default: {\r\n        this.WriteTagEquals(tag)\r\n        break\r\n      }\r\n    }\r\n\r\n    switch (tagType) {\r\n      case TagType.String: {\r\n        buffer.writeString(val as string)\r\n        break\r\n      }\r\n\r\n      case TagType.Float: {\r\n        buffer.writeNumber(val as number)\r\n        break\r\n      }\r\n\r\n      case TagType.Int:\r\n      case TagType.Length: {\r\n        buffer.writeWholeNumber(val as number)\r\n        break\r\n      }\r\n\r\n      case TagType.Boolean: {\r\n        buffer.writeBoolean(val as boolean)\r\n        break\r\n      }\r\n\r\n      case TagType.UtcTimestamp: {\r\n        tf.writeUtcTimestamp(val as Date)\r\n        break\r\n      }\r\n\r\n      case TagType.UtcTimeOnly: {\r\n        tf.writeUtcTime(val as Date)\r\n        break\r\n      }\r\n\r\n      case TagType.UtcDateOnly: {\r\n        tf.writeUtcDate(val as Date)\r\n        break\r\n      }\r\n\r\n      case TagType.LocalDate: {\r\n        tf.writeLocalDate(val as Date)\r\n        break\r\n      }\r\n\r\n      case TagType.RawData: {\r\n        const b = val as Buffer\r\n        const lenField: ContainedSimpleField = set.fields[sf.position - 1] as ContainedSimpleField\r\n        if (o[lenField.name] == null) {\r\n          this.WriteTagEquals(lenField.definition.tag)\r\n          buffer.writeWholeNumber(b.length)\r\n          buffer.writeChar(delimiter)\r\n        }\r\n        this.WriteTagEquals(tag)\r\n        buffer.writeBuffer(b)\r\n        break\r\n      }\r\n\r\n      default: {\r\n        buffer.writeString(val as string)\r\n        break\r\n      }\r\n    }\r\n\r\n    buffer.writeChar(delimiter)\r\n\r\n    switch (tag) {\r\n      case Tags.BodyLengthTag:\r\n        this.bodyLengthPos = pos + 2\r\n        break\r\n    }\r\n  }\r\n}\r\n"]}