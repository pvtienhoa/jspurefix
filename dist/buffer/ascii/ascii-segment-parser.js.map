{"version":3,"file":"ascii-segment-parser.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-segment-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContainedComponentField, ContainedFieldType, ContainedGroupField, ContainedSimpleField, ComponentFieldDefinition, FixDefinitions, MessageDefinition } from '../../dictionary'\r\nimport { SegmentDescription, SegmentType } from '../segment-description'\r\nimport { Structure } from '../structure'\r\nimport { Tags } from '../tags'\r\nimport { MsgTag } from '../../types/enum'\r\n\r\nexport class AsciiSegmentParser {\r\n\r\n  private readonly headerDefinition: ComponentFieldDefinition\r\n  private readonly trailerDefinition: ComponentFieldDefinition\r\n\r\n  constructor (public readonly definitions: FixDefinitions) {\r\n    this.headerDefinition = definitions.component.get('header')\r\n    this.trailerDefinition = definitions.component.get('trailer')\r\n  }\r\n\r\n  public parse (msgType: string, tags: Tags, last: number): Structure {\r\n    const segments: SegmentDescription[] = []\r\n    const tr = this.trailerDefinition\r\n    const hd = this.headerDefinition\r\n    const msgDefinition: MessageDefinition = this.definitions.message.get(msgType)\r\n    if (!msgDefinition) {\r\n      return null\r\n    }\r\n    const structureStack: SegmentDescription[] = []\r\n    let currentTagPosition: number = 0\r\n    // let currentContainedField: ContainedField;\r\n    let peek: SegmentDescription\r\n\r\n    function init (): void {\r\n      const firstTag: number = tags.tagPos[0].tag\r\n      structureStack[structureStack.length] = new SegmentDescription(tr.name, tags.tagPos[last].tag, tr,\r\n        currentTagPosition, structureStack.length, SegmentType.Component)\r\n      structureStack[structureStack.length] = new SegmentDescription(msgDefinition.name, firstTag, msgDefinition,\r\n        currentTagPosition, structureStack.length, SegmentType.Msg)\r\n      structureStack[structureStack.length] = new SegmentDescription(hd.name, firstTag, hd,\r\n        currentTagPosition, structureStack.length, SegmentType.Component)\r\n    }\r\n\r\n    // having finished one segments keep unwinding until tag matches further up stack\r\n    function unwind (tag: number): void {\r\n      while (structureStack.length > 1) {\r\n        const done: SegmentDescription = structureStack.pop()\r\n        done.end(segments.length, currentTagPosition - 1, tags.tagPos[currentTagPosition - 1].tag)\r\n        segments[segments.length] = done\r\n        peek = structureStack[structureStack.length - 1]\r\n        if (peek.set.containedTag[tag]) {\r\n          // unwound to point this tag lives in this set.\r\n          break\r\n        }\r\n        if (peek.type === SegmentType.Msg && !tr.localTag[tag]) {\r\n          // this is unknown tag and it is not part of trailer so raise unknown\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    function examine (tag: number): void {\r\n      switch (peek.currentField.type) {\r\n\r\n        case ContainedFieldType.Simple: {\r\n          const sf: ContainedSimpleField = peek.currentField as ContainedSimpleField\r\n          if (sf.definition.tag === tag) {\r\n            currentTagPosition = currentTagPosition + 1\r\n          }\r\n          break\r\n        }\r\n        // moving deeper into structure, start a new context\r\n        case ContainedFieldType.Component: {\r\n          const cf: ContainedComponentField = peek.currentField as ContainedComponentField\r\n          structureStack[structureStack.length] = new SegmentDescription(cf.name, tag, cf.definition,\r\n                        currentTagPosition, structureStack.length - 1, SegmentType.Component)\r\n          break\r\n        }\r\n\r\n        case ContainedFieldType.Group: {\r\n          const gf: ContainedComponentField = peek.currentField as ContainedGroupField\r\n          const structure: SegmentDescription = new SegmentDescription(gf.name, tag, gf.definition,\r\n                        currentTagPosition, structureStack.length - 1, SegmentType.Group)\r\n          structureStack[structureStack.length] = structure\r\n          currentTagPosition = currentTagPosition + 1\r\n          structure.startGroup(tags.tagPos[currentTagPosition].tag)\r\n          break\r\n        }\r\n\r\n        default:\r\n          throw new Error(`unknown tag type ${tag}`)\r\n      }\r\n    }\r\n\r\n    function groupDelimiter (tag: number): boolean {\r\n      let delimiter: boolean = false\r\n      if (tag === peek.delimiterTag) {\r\n        peek.addDelimiterPosition(currentTagPosition)\r\n      } else if (structureStack.length > 1) {\r\n                // if a group is represented by a repeated component, then the tag representing delimiter\r\n                // needs to be added further up stack to group itself.\r\n        delimiter = structureStack[structureStack.length - 2].groupAddDelimiter(tag, currentTagPosition)\r\n      }\r\n      return delimiter\r\n    }\r\n\r\n    function gap (tag: number): void {\r\n      const gap = new SegmentDescription('.undefined', tag, peek.set,\r\n        currentTagPosition, structureStack.length, SegmentType.Gap)\r\n      gap.end(segments.length, currentTagPosition, tag)\r\n      segments[segments.length] = gap\r\n      currentTagPosition++\r\n    }\r\n\r\n    function discover (): void {\r\n      while (currentTagPosition <= last) {\r\n        const tag: number = tags.tagPos[currentTagPosition].tag\r\n        peek = structureStack[structureStack.length - 1]\r\n        peek.setCurrentField(tag)\r\n        if (!peek.set.containedTag[tag] || groupDelimiter(tag)) {\r\n          const unknown = peek.type === SegmentType.Msg && tag !== MsgTag.CheckSum\r\n          if (unknown) {\r\n            gap(tag)\r\n          } else if (structureStack.length > 1) {\r\n            // move back up the segments and save the finished group / component\r\n            unwind(tag)\r\n          }\r\n          continue\r\n        }\r\n        examine(tag)\r\n      }\r\n    }\r\n\r\n    function clean (): void {\r\n      while (structureStack.length > 0) {\r\n        const done: SegmentDescription = structureStack.pop()\r\n        done.end(segments.length, currentTagPosition - 1, tags.tagPos[currentTagPosition - 1].tag)\r\n        segments[segments.length] = done\r\n      }\r\n      const msg: SegmentDescription = segments[segments.length - 2]\r\n      const trl: SegmentDescription = segments[segments.length - 1]\r\n      msg.startTag = tags.tagPos[msg.startPosition].tag\r\n      trl.startPosition = msg.endPosition + 1\r\n      msg.endPosition = trl.endPosition\r\n    }\r\n\r\n    init()\r\n    discover()\r\n    clean()\r\n\r\n    return new Structure(tags, segments)\r\n  }\r\n}\r\n"]}