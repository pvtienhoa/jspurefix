{"version":3,"file":"ascii-parser.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { FixDefinitions } from '../../dictionary'\r\nimport { AsciiChars } from '../ascii-chars'\r\nimport { AsciiView } from './ascii-view'\r\nimport { AsciiSegmentParser } from './ascii-segment-parser'\r\nimport { AsciiParserState, ParseState } from './ascii-parser-state'\r\nimport { Structure } from '../structure'\r\nimport { Tags } from '../tags'\r\nimport { MsgParser } from '../msg-parser'\r\nimport { MsgView } from '../msg-view'\r\nimport { Readable } from 'stream'\r\nimport { ElasticBuffer } from '../elastic-buffer'\r\nimport { SegmentDescription, SegmentType } from '../segment-description'\r\n\r\nexport class AsciiParser extends MsgParser {\r\n  private static nextId: number = 0\r\n  public readonly id: number\r\n  public readonly state: AsciiParserState\r\n  private readonly receivingBuffer: ElasticBuffer\r\n  private readonly segmentParser: AsciiSegmentParser\r\n\r\n  // allocate enough in receive buffer so buffer does not constant resize back after large messages\r\n  // want to keep one slice of memory and constantly reuse it\r\n\r\n  constructor (public readonly definitions: FixDefinitions,\r\n               public readonly readStream: Readable,\r\n               public readonly delimiter: number,\r\n               public readonly writeDelimiter: number = delimiter,\r\n               public readonly maxMessageLen: number = 160 * 1024) {\r\n    super()\r\n    this.id = AsciiParser.nextId++\r\n    this.segmentParser = new AsciiSegmentParser(definitions)\r\n    this.receivingBuffer = new ElasticBuffer(maxMessageLen)\r\n    this.state = new AsciiParserState(this.receivingBuffer)\r\n    this.state.locations = new Tags(definitions, maxMessageLen / 10)\r\n    this.state.beginMessage()\r\n    this.subscribe()\r\n  }\r\n\r\n  private subscribe (): void {\r\n    const inst: AsciiParser = this\r\n    const Writable = require('stream').Writable\r\n    const stream = this.readStream\r\n\r\n    const receiver = new Writable({\r\n      write: (data: Buffer, _: any, done: Function) => {\r\n        try {\r\n          inst.parse(data, data.length)\r\n          done()\r\n        } catch (e) {\r\n          done(e)\r\n        }\r\n      }\r\n    })\r\n    receiver.on('error', (e: Error) => {\r\n      this.emit('error', e)\r\n    })\r\n\r\n    // receive from say a socket or file and pipe to parser which discovers messages\r\n    stream.pipe(receiver).on('finish', () => {\r\n      this.emit('done')\r\n    })\r\n    stream.on('error', (e) => {\r\n      this.emit('error', e)\r\n    })\r\n    stream.on('end', () => {\r\n      this.emit('end')\r\n    })\r\n  }\r\n\r\n  private msg (ptr: number): void {\r\n    const receivingBuffer: ElasticBuffer = this.receivingBuffer\r\n    const state = this.state\r\n    if (this.listeners('decoded')) {\r\n      this.emit('decoded', state.msgType, receivingBuffer, ptr)\r\n    }\r\n    this.emit('msg', state.msgType, this.getView(ptr))\r\n    state.beginMessage()\r\n  }\r\n\r\n  private parse (readBuffer: Buffer, end: number): void {\r\n    const state = this.state\r\n    const eq: number = AsciiChars.Eq\r\n    const zero: number = AsciiChars.Zero\r\n    const nine: number = AsciiChars.Nine\r\n    const delimiter: number = this.delimiter\r\n    const writeDelimiter: number = this.writeDelimiter\r\n    const receivingBuffer: ElasticBuffer = this.receivingBuffer\r\n    const switchDelimiter = writeDelimiter !== delimiter\r\n    let readPtr: number = 0\r\n\r\n    while (readPtr < end) {\r\n      let charAtPos: number = readBuffer[readPtr]\r\n\r\n      const writePtr = receivingBuffer.saveChar(charAtPos) - 1\r\n      switch (state.parseState) {\r\n\r\n        case ParseState.MsgComplete: {\r\n          this.msg(writePtr)\r\n          continue\r\n        }\r\n\r\n        case ParseState.BeginField: {\r\n          const atDigit: boolean = charAtPos >= zero && charAtPos <= nine\r\n          if (atDigit) {\r\n            state.beginTag(writePtr)\r\n          }\r\n          break\r\n        }\r\n\r\n        case ParseState.ParsingTag: {\r\n          const isEquals: boolean = charAtPos === eq\r\n          if (isEquals) {\r\n            state.endTag(writePtr)\r\n          }\r\n          break\r\n        }\r\n\r\n        case ParseState.ParsingRawData: {\r\n          // keep skipping until length read, regardless of delimiter or not\r\n          if (state.incRaw()) {\r\n            // having consumed the raw field expecting delimiter\r\n            if (charAtPos === delimiter) {\r\n              if (switchDelimiter) {\r\n                receivingBuffer.switchChar(writeDelimiter)\r\n              }\r\n              state.store()\r\n            } else {\r\n              throw new Error(`delimiter (${delimiter}) expected at position ${readPtr} when value is ${charAtPos}`)\r\n            }\r\n          }\r\n          break\r\n        }\r\n\r\n        case ParseState.ParsingRawDataLength:\r\n        case ParseState.ParsingValue: {\r\n          if (charAtPos === delimiter) {\r\n            if (switchDelimiter) {\r\n              receivingBuffer.switchChar(writeDelimiter)\r\n            }\r\n            state.store()\r\n          }\r\n          break\r\n        }\r\n\r\n        default: {\r\n          throw new Error(`fix parser in unknown state ${state}`)\r\n        }\r\n      }\r\n      readPtr++\r\n    }\r\n\r\n    switch (state.parseState) {\r\n      case ParseState.MsgComplete: {\r\n        this.msg(receivingBuffer.getPos())\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  private getView (ptr: number): MsgView {\r\n    const state = this.state\r\n    const locations = state.locations\r\n    const source = this.receivingBuffer\r\n    const delimiter = this.delimiter\r\n    const replace = this.writeDelimiter\r\n    if (state.message) {\r\n      const structure: Structure = this.segmentParser.parse(state.msgType, locations,\r\n        locations.nextTagPos - 1)\r\n      return new AsciiView(structure.msg(),\r\n        source,\r\n        structure,\r\n        ptr,\r\n        delimiter,\r\n        replace)\r\n    }\r\n\r\n    const structure = new Structure(locations, [])\r\n    const segment = new SegmentDescription('unknown', locations.tagPos[0].tag, null, 0, 1, SegmentType.Unknown)\r\n    segment.endPosition = locations.nextTagPos - 1\r\n    return new AsciiView(segment, source, structure, ptr, delimiter, replace)\r\n  }\r\n}\r\n"]}