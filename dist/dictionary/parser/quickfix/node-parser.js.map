{"version":3,"file":"node-parser.js","sourceRoot":"","sources":["../../../../src/dictionary/parser/quickfix/node-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContainedGroupField, ContainedSimpleField, ContainedComponentField } from '../../contained'\r\nimport { ISaxNode } from '../../dict-primitive'\r\nimport { FixDefinitions, GroupFieldDefinition, SimpleFieldDefinition, ComponentFieldDefinition } from '../../definition'\r\nimport { ParseContext } from './parse-context'\r\nimport { QuickFixXmlFileParser } from './quick-fix-xml-file-parser'\r\n\r\nexport abstract class NodeParser {\r\n  protected readonly parseContexts: ParseContext[] = []\r\n  protected readonly definitions: FixDefinitions\r\n\r\n  protected constructor (public readonly parser: QuickFixXmlFileParser) {\r\n    this.definitions = parser.definitions\r\n  }\r\n\r\n  public abstract open (line: number, node: ISaxNode): void\r\n\r\n  public abstract close (line: number, node: string): void\r\n\r\n  protected addSimple (node: ISaxNode): void {\r\n    if (node.isSelfClosing) {\r\n      const parent: ParseContext = this.peek()\r\n      if (parent == null) {\r\n        throw new Error(`simple field ${node.name} has no parent on which to add.`)\r\n      }\r\n      const fieldName: string = node.attributes.name\r\n      const fieldDefinition: SimpleFieldDefinition = this.definitions.simple.get(fieldName)\r\n      if (fieldDefinition == null) {\r\n        throw new Error(`simple field ${fieldName} has no declaration in dictionary.`)\r\n      }\r\n      const containedField: ContainedSimpleField = new ContainedSimpleField(fieldDefinition,\r\n                parent.set.fields.length, node.attributes.required === 'Y', false)\r\n      parent.set.add(containedField)\r\n    }\r\n  }\r\n\r\n  protected addComponentField (componentName: string, node: ISaxNode): void {\r\n    const parent: ParseContext = this.peek()\r\n    if (parent == null) {\r\n      throw new Error(`component ${node.name} has no parent on which to add.`)\r\n    }\r\n    const fieldDef: ComponentFieldDefinition = this.definitions.component.get(componentName)\r\n    if (fieldDef != null) {\r\n      const containedField: ContainedComponentField =\r\n                new ContainedComponentField(fieldDef, parent.set.fields.length, parent.required)\r\n      parent.set.add(containedField)\r\n    } else {\r\n      if (this.parser.numberPasses >= 4) {\r\n        throw new Error(`field ${node.name} includes unknown component ${componentName}.`)\r\n      }\r\n    }\r\n  }\r\n\r\n  protected addGroupField (name: string): void {\r\n    const group: ParseContext = this.parseContexts.pop()\r\n    if (group == null) {\r\n      throw new Error(`group field ${name} closes yet does not exist.`)\r\n    }\r\n    const parent: ParseContext = this.peek()\r\n    if (parent != null) {\r\n      const asGroup: GroupFieldDefinition = group.asGroup()\r\n      const containedField: ContainedGroupField =\r\n                new ContainedGroupField(asGroup, parent.set.fields.length, group.required)\r\n      parent.set.add(containedField)\r\n    } else {\r\n      throw new Error(`group field ${group.name} has no parent on which to add.`)\r\n    }\r\n  }\r\n\r\n  protected beginGroupDefinition (node: ISaxNode): void {\r\n    if (!node.isSelfClosing) {\r\n            // a group should have a field that matches its name\r\n      const groupName: string = node.attributes.name\r\n      const noOfField: SimpleFieldDefinition = this.definitions.simple.get(groupName)\r\n      if (noOfField == null) {\r\n        const msg: string = `group ${groupName} has no field defined.`\r\n        throw new Error(msg)\r\n      }\r\n      const set: GroupFieldDefinition = new GroupFieldDefinition(groupName, groupName, null, noOfField,null)\r\n      const context: ParseContext = new ParseContext(node.attributes.name, true, set)\r\n      context.required = node.attributes.required === 'Y'\r\n      this.parseContexts.push(context)\r\n    }\r\n  }\r\n\r\n  private peek (): ParseContext {\r\n    return this.parseContexts.length > 0 ? this.parseContexts[this.parseContexts.length - 1] : null\r\n  }\r\n}\r\n"]}