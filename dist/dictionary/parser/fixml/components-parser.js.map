{"version":3,"file":"components-parser.js","sourceRoot":"","sources":["../../../../src/dictionary/parser/fixml/components-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ISaxNode } from '../../dict-primitive'\r\nimport { Dictionary } from '../../../collections'\r\nimport { XsdParser } from './xsd-parser'\r\nimport { ComponentFieldDefinition, SimpleFieldDefinition, GroupFieldDefinition, FixDefinitions, MessageDefinition } from '../../definition'\r\nimport { ContainedSimpleField, ContainedComponentField, ContainedFieldSet, ContainedGroupField } from '../../contained'\r\n\r\ninterface IElement {\r\n  ref: string\r\n  name: string\r\n  type: string\r\n  minOccurs: string\r\n  maxOccurs: string\r\n  substitutionGroup: string\r\n}\r\n\r\ninterface IAttribute {\r\n  name: string\r\n  type: string\r\n  use: string\r\n}\r\n\r\ninterface IAttributeGroup {\r\n  name: string\r\n  attributes: IAttribute[]\r\n}\r\n\r\ninterface IGroup {\r\n  name: string\r\n  elements: IElement[]\r\n}\r\n\r\ninterface IAppInfo {\r\n  Protocol: string\r\n  MsgID: string\r\n  name: string,\r\n  ComponentType: string\r\n  Category: string\r\n}\r\n\r\n/*\r\n      <xs:complexContent>\r\n         <xs:extension base=\"BaseHeader_t\">\r\n            <xs:sequence>\r\n               <xs:group ref=\"BatchHeaderElements\"/>\r\n            </xs:sequence>\r\n            <xs:attributeGroup ref=\"BatchHeaderAttributes\"/>\r\n         </xs:extension>\r\n      </xs:complexContent>\r\n */\r\n\r\ninterface IAnnotation {\r\n  documentation: string\r\n}\r\n\r\ninterface IComplexType {\r\n  annotation: IAnnotation\r\n  extensionBase: string // where a reference to base class\r\n  element: IElement[]\r\n  messageName: string\r\n  name: string\r\n  appInfo: IAppInfo\r\n  group: string\r\n  attributeGroup: string\r\n}\r\n\r\nexport class ComponentsParser extends XsdParser {\r\n  private readonly attributeGroups: Dictionary<IAttributeGroup> = new Dictionary<IAttributeGroup>()\r\n  private readonly groups: Dictionary<IGroup> = new Dictionary<IGroup>()\r\n  private readonly unboundElements: IElement[] = []\r\n  private readonly complexTypes: Dictionary<IComplexType> = new Dictionary<IComplexType>()\r\n\r\n  private newComplexTypes: IComplexType[]\r\n  private currentGroup: IGroup\r\n  private currentAttributeGroupStack: IAttributeGroup[] = []\r\n  private currentComplexType: IComplexType\r\n  private previousComplexType: IComplexType\r\n\r\n  public constructor (public readonly definitions: FixDefinitions) {\r\n    super(definitions)\r\n  }\r\n\r\n  private static getName (group: IGroup, attributeGroup: IAttributeGroup, type: IComplexType): string {\r\n    let name: string\r\n    if (type && type.appInfo) {\r\n      name = type.appInfo.name\r\n    } else if (group) {\r\n      name = group.name\r\n    } else if (attributeGroup) {\r\n      name = attributeGroup.name\r\n    } else {\r\n      name = type.name\r\n    }\r\n    return name\r\n  }\r\n\r\n  public value (line: number, n: string, v: string): void {\r\n    // do nothing\r\n    switch (n) {\r\n      case 'xs:documentation': {\r\n        if (this.currentComplexType && this.currentComplexType.annotation) {\r\n          this.currentComplexType.annotation.documentation = v\r\n        }\r\n        break\r\n      }\r\n    }\r\n    this.pending = null\r\n  }\r\n\r\n  public close (line: number, node: string): void {\r\n    switch (node) {\r\n      case'xs:complexType': {\r\n        if (this.currentComplexType != null) {\r\n          const complex: IComplexType = this.currentComplexType\r\n          this.previousComplexType = complex\r\n          this.complexTypes.addUpdate(complex.name, complex)\r\n          this.newComplexTypes.push(complex)\r\n          this.currentComplexType = null\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'xs:group': {\r\n        if (this.currentGroup) {\r\n          this.groups.addUpdate(this.currentGroup.name, this.currentGroup)\r\n          this.currentGroup = null\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'xs:attributeGroup': {\r\n        const attributeStack = this.currentAttributeGroupStack\r\n        if (attributeStack.length > 0) {\r\n          const group: IAttributeGroup = attributeStack.pop()\r\n          this.attributeGroups.addUpdate(group.name, group)\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'xs:schema': {\r\n        this.insertFields()\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  public open (line: number, node: ISaxNode): void {\r\n    switch (node.name) {\r\n\r\n      case 'xs:schema': {\r\n        this.newComplexTypes = []\r\n        break\r\n      }\r\n\r\n      case 'xs:group': {\r\n        this.xsGroup(node)\r\n        break\r\n      }\r\n\r\n      case 'xs:attributeGroup': {\r\n        this.xsAttributeGroup(node)\r\n        break\r\n      }\r\n\r\n      case 'xs:element': {\r\n        this.xsElement(node)\r\n        break\r\n      }\r\n\r\n      case 'xs:appinfo': {\r\n        this.currentComplexType.appInfo = {\r\n        } as IAppInfo\r\n        break\r\n      }\r\n\r\n      case 'xs:attribute': {\r\n        this.xsAttribute(node)\r\n        break\r\n      }\r\n\r\n      case 'xs:complexType': {\r\n        const unbound = this.unboundElements\r\n        this.currentComplexType = {\r\n          name: node.attributes.name || unbound[unbound.length - 1].name\r\n        } as IComplexType\r\n        break\r\n      }\r\n\r\n      case 'xs:extension': {\r\n        const current = this.currentComplexType\r\n        if (current && node.attributes.base) {\r\n          current.extensionBase = node.attributes.base\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'fm:Xref': {\r\n        this.assign(node, this.currentComplexType.appInfo)\r\n        break\r\n      }\r\n\r\n      case 'xs:annotation': {\r\n        if (this.currentComplexType) {\r\n          this.currentComplexType.annotation = {} as IAnnotation\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'xs:documentation': {\r\n        if (this.currentComplexType) {\r\n          this.pending = node.name\r\n        }\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  private xsAttribute (node: ISaxNode) {\r\n    const attribute: IAttribute = {} as IAttribute\r\n    this.assign(node, attribute)\r\n    const stack = this.currentAttributeGroupStack\r\n    if (stack.length > 0) {\r\n      const peek = stack[stack.length - 1]\r\n      const groupAttributes: IAttribute[] = peek.attributes\r\n      groupAttributes[groupAttributes.length] = attribute\r\n    }\r\n  }\r\n\r\n  private xsGroup (node: ISaxNode) {\r\n    if (node.attributes.name) {\r\n      this.currentGroup = {\r\n        name: node.attributes['name'],\r\n        elements: [] as IElement[]\r\n      } as IGroup\r\n    } else if (node.attributes.ref) {\r\n      if (this.currentComplexType) {\r\n        this.currentComplexType.group = node.attributes.ref\r\n      } else if (this.currentGroup) {\r\n        // this is part of a sequence for a group\r\n        const elements = this.currentGroup.elements\r\n        elements[elements.length] = {\r\n          type: node.name,\r\n          name: node.attributes.ref\r\n        } as IElement\r\n      }\r\n    }\r\n  }\r\n\r\n  private xsAttributeGroup (node: ISaxNode) {\r\n    const attributeStack = this.currentAttributeGroupStack\r\n    if (node.attributes.name) {\r\n      attributeStack.push({\r\n        name: node.attributes.name,\r\n        attributes: [] as IAttribute[]\r\n      } as IAttributeGroup)\r\n    } else if (node.attributes.ref) {\r\n      if (this.currentComplexType) {\r\n        this.currentComplexType.attributeGroup = node.attributes.ref\r\n      } else if (attributeStack.length > 0) {\r\n        const peek: IAttributeGroup = attributeStack[attributeStack.length - 1]\r\n        peek.attributes[peek.attributes.length] = {\r\n          type: node.name,\r\n          name: node.attributes.ref\r\n        } as IAttribute\r\n      }\r\n    }\r\n  }\r\n\r\n  private xsElement (node: ISaxNode) {\r\n    const element: IElement = {} as IElement\r\n    this.assign(node, element)\r\n    const currentComplex = this.currentComplexType\r\n    const currentGroup = this.currentGroup\r\n    if (!currentGroup && currentComplex) {\r\n      if (!currentComplex.element) {\r\n        currentComplex.element = []\r\n      }\r\n      const elements: IElement[] = currentComplex.element\r\n      elements[elements.length] = element\r\n    } else if (currentGroup) {\r\n      const elements = currentGroup.elements\r\n      elements[elements.length] = element\r\n    } else {\r\n      if (element.substitutionGroup && this.previousComplexType) {\r\n        this.previousComplexType.messageName = element.name\r\n      } else {\r\n        this.unboundElements.push(element)\r\n      }\r\n    }\r\n  }\r\n\r\n  private addElement (set: ContainedFieldSet, element: IElement) {\r\n    const minOccurs: number = parseInt(element.minOccurs, 10)\r\n    const isGroup: boolean = element.maxOccurs === 'unbounded'\r\n    const isComponent: boolean = element.maxOccurs === '1' || !isGroup\r\n    const key = element.type || element.ref || element.name\r\n    const containedType: IComplexType = this.complexTypes.get(key)\r\n    if (containedType) {\r\n      if (isComponent) {\r\n        const containedDefinition: ComponentFieldDefinition = this.getComponent(containedType)\r\n        const containedField: ContainedComponentField =\r\n          new ContainedComponentField(containedDefinition,\r\n            set.fields.length,\r\n            minOccurs > 0,\r\n            element.name)\r\n        set.add(containedField)\r\n      } else if (isGroup) {\r\n        const containedDefinition: GroupFieldDefinition = this.getGroup(containedType)\r\n        const containedField: ContainedGroupField =\r\n          new ContainedGroupField(containedDefinition,\r\n            set.fields.length,\r\n            minOccurs > 0,\r\n            element.name)\r\n        set.add(containedField)\r\n      }\r\n    } else {\r\n      if (key !== 'Message') {\r\n        throw new Error(`cannot resolve component ${key} contained in ${set.name}`)\r\n      }\r\n    }\r\n  }\r\n\r\n  private addElements (set: ContainedFieldSet, elements: IElement[]) {\r\n    if (elements) {\r\n      elements.forEach((element: IElement) => {\r\n        switch (element.type) {\r\n          case 'xs:group':\r\n            const groupElements: IGroup = this.groups.get(element.name)\r\n            if (groupElements) {\r\n              this.addElements(set, groupElements.elements)\r\n            } else {\r\n              throw new Error(`unable to get xs:group ${element.name}`)\r\n            }\r\n            break\r\n\r\n          default: {\r\n            this.addElement(set, element)\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  private addSimpleAttribute (set: ContainedFieldSet, attribute: IAttribute): void {\r\n    let sf: SimpleFieldDefinition = this.definitions.getSimple(attribute.type)\r\n    if (!sf) {\r\n      sf = this.definitions.getSimple(attribute.name, set.category)\r\n    }\r\n    if (sf) {\r\n      const contained: ContainedSimpleField = new ContainedSimpleField(sf,\r\n        set.fields.length,\r\n        attribute.use !== 'optional',\r\n        true,\r\n        attribute.name)\r\n      set.add(contained)\r\n    } else if (set.name !== 'FixmlAttributes') {\r\n      throw new Error(`unable to resolve simple attribute ${attribute.name}`)\r\n    }\r\n  }\r\n\r\n  private addAttributes (set: ContainedFieldSet, attributes: IAttribute[]) {\r\n\r\n    attributes.forEach((attribute: IAttribute) => {\r\n      switch (attribute.type) {\r\n        case 'xs:attributeGroup': {\r\n          const attributeGroup: IAttributeGroup = this.attributeGroups.get(attribute.name)\r\n          if (attributeGroup) {\r\n            this.addAttributes(set, attributeGroup.attributes)\r\n          } else {\r\n            throw new Error(`unable to get xs:attributeGroup ${attribute.name}`)\r\n          }\r\n          break\r\n        }\r\n\r\n        default: {\r\n          this.addSimpleAttribute(set, attribute)\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  private getGroup (type: IComplexType): GroupFieldDefinition {\r\n    let group: IGroup = this.groups.get(type.group)\r\n    const attributeGroup: IAttributeGroup = this.attributeGroups.get(type.attributeGroup)\r\n    const name: string = ComponentsParser.getName(group, attributeGroup, type)\r\n    const category: string = type.appInfo != null ? type.appInfo.Category : null\r\n    const groupDefinition: GroupFieldDefinition = new GroupFieldDefinition(name, name, category, null, null)\r\n    this.populateSet(type, groupDefinition)\r\n    return groupDefinition\r\n  }\r\n\r\n  private getComponent (type: IComplexType): ComponentFieldDefinition {\r\n    const definitions = this.definitions\r\n    let group: IGroup = this.groups.get(type.group)\r\n    const attributeGroup: IAttributeGroup = this.attributeGroups.get(type.attributeGroup)\r\n    let name: string = ComponentsParser.getName(group, attributeGroup, type)\r\n    const cached: ComponentFieldDefinition = definitions.component.get(name)\r\n    if (cached) {\r\n      return cached\r\n    }\r\n\r\n    const category: string = type.appInfo != null ? type.appInfo.Category : null\r\n    if (type.extensionBase) {\r\n      let base = this.complexTypes.get(type.extensionBase)\r\n      if (base) {\r\n        name = base.appInfo.name\r\n      }\r\n    }\r\n    const component: ComponentFieldDefinition = new ComponentFieldDefinition(name, name, category, null)\r\n    this.populateSet(type, component)\r\n    definitions.component.addUpdate(component.name, component)\r\n    definitions.component.addUpdate(type.name, component)\r\n    return component\r\n  }\r\n\r\n  private getMessage (type: IComplexType): MessageDefinition {\r\n    const definitions = this.definitions\r\n    const messages = definitions.message\r\n    const name: string = type.appInfo.name\r\n    const message: MessageDefinition = new MessageDefinition(name,\r\n      type.messageName,\r\n      type.appInfo.MsgID,\r\n      type.appInfo.Category,\r\n      type.annotation.documentation)\r\n    const abstractMessage: ComponentFieldDefinition = definitions.component.get('Message')\r\n    abstractMessage.fields.forEach((f) => {\r\n      message.add(f)\r\n    })\r\n    this.populateSet(type, message)\r\n    messages.addUpdate(message.name, message)\r\n    if (type.messageName && type.messageName !== name) {\r\n      messages.addUpdate(type.messageName, message)\r\n    }\r\n\r\n    return message\r\n  }\r\n\r\n  private getBaseAttributes (type: IComplexType): IAttributeGroup {\r\n    const attributeGroups = this.attributeGroups\r\n    let baseGroup: IAttributeGroup = null\r\n    if (type.extensionBase) {\r\n      let base = this.complexTypes.get(type.extensionBase)\r\n      if (base) {\r\n        baseGroup = attributeGroups.get(base.attributeGroup)\r\n      }\r\n      return baseGroup\r\n    }\r\n    return null\r\n  }\r\n\r\n  private populateSet (type: IComplexType, set: ContainedFieldSet): void {\r\n    const group: IGroup = this.groups.get(type.group)\r\n    const elements: IElement[] = group ? group.elements : type.element\r\n    const attributeGroups = this.attributeGroups\r\n    const attributeGroup: IAttributeGroup = attributeGroups.get(type.attributeGroup)\r\n    const baseGroup: IAttributeGroup = this.getBaseAttributes(type)\r\n    // if a base is specified add the attributes from there\r\n    if (baseGroup) {\r\n      this.addAttributes(set, baseGroup.attributes)\r\n    }\r\n    if (attributeGroup) {\r\n      this.addAttributes(set, attributeGroup.attributes)\r\n    }\r\n    this.addElements(set, elements)\r\n  }\r\n\r\n  private constructType (type: IComplexType) {\r\n    const componentType: string = type.appInfo != null ? type.appInfo.ComponentType : 'Block'\r\n    switch (componentType) {\r\n\r\n      case 'Message': {\r\n        const message: MessageDefinition = this.getMessage(type)\r\n        if (!message) {\r\n          throw new Error(`cannot resolve ${type.name}`)\r\n        }\r\n        break\r\n      }\r\n\r\n      // these may be included from top level messages and added into definitions\r\n      case 'Block': {\r\n        const component: ComponentFieldDefinition = this.getComponent(type)\r\n        if (!component) {\r\n          throw new Error(`cannot resolve ${type.name}`)\r\n        }\r\n        break\r\n      }\r\n\r\n      case 'ImplicitBlock':\r\n      case 'XMLDataBlock':\r\n      case 'BlockRepeating':\r\n      case 'ImplicitBlockRepeating': {\r\n        break\r\n      }\r\n\r\n      default:\r\n        throw new Error(`unknown type ${componentType}`)\r\n    }\r\n  }\r\n\r\n  private insertFields (): void {\r\n    this.newComplexTypes.forEach((type: IComplexType) => {\r\n      this.constructType(type)\r\n    })\r\n    this.unboundElements.forEach((e: IElement) => {\r\n      const definitions = this.definitions\r\n      const component = definitions.component.get(e.type)\r\n      if (component) {\r\n        definitions.component.addUpdate(e.name, component)\r\n      }\r\n    })\r\n  }\r\n}\r\n"]}