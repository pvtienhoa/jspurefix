{"version":3,"file":"include-graph.js","sourceRoot":"","sources":["../../../../src/dictionary/parser/fixml/include-graph.ts"],"names":[],"mappings":"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","sourcesContent":["import { ISaxNode, SAXStream } from '../../dict-primitive'\r\nimport { Dictionary } from '../../../collections'\r\nimport { INumericKeyed } from '../../../collections/collection'\r\nimport * as path from 'path'\r\nimport * as fs from 'fs'\r\n\r\nexport interface IInclude {\r\n  parent: string\r\n  children: string[]\r\n}\r\n\r\nexport interface IGraphNode {\r\n  file: string\r\n  node: number\r\n  edges: number[]\r\n}\r\n\r\n/*\r\n  construct a dependency graph from all the xsd files to compute an order to build the definition\r\n */\r\n\r\nexport class IncludeGraph {\r\n  private nodes: Dictionary<number>\r\n  private includes: IInclude[]\r\n  private graph: INumericKeyed<IGraphNode>\r\n  constructor (public readonly root: string, public readonly main: string) {\r\n  }\r\n\r\n  public async build (): Promise<any> {\r\n    this.includes = await this.getIncludes(this.main)\r\n    this.assignNodes()\r\n    this.getGraph()\r\n  }\r\n\r\n  public resolve (file: string): string[] {\r\n    const label: number = this.nodes.get(file)\r\n    if (label == null) {\r\n      return null\r\n    }\r\n    const depends: number[] = []\r\n    this.resolve_nodes(label, depends)\r\n    return depends.map((i: number) => {\r\n      return this.graph[i].file\r\n    })\r\n  }\r\n\r\n  private resolve_nodes (label: number, depends: number[]): void {\r\n    const node: IGraphNode = this.graph[label]\r\n    for (let e of node.edges) {\r\n      if (depends.indexOf(e) < 0) {\r\n        this.resolve_nodes(e, depends)\r\n      }\r\n    }\r\n    depends.push(label)\r\n  }\r\n\r\n  private getGraph () {\r\n    const nodes = this.nodes\r\n    this.graph = this.includes.reduce((a: INumericKeyed<IGraphNode>, current: IInclude) => {\r\n      const parent: number = nodes.get(current.parent)\r\n      let parentNode = a[parent]\r\n      if (!parentNode) {\r\n        a[parent] = parentNode = {\r\n          file: current.parent,\r\n          node: parent,\r\n          edges: []\r\n        } as IGraphNode\r\n      }\r\n      current.children.forEach((s: string) => {\r\n        const child: number = nodes.get(s)\r\n        if (parentNode.edges.indexOf(child) < 0) {\r\n          parentNode.edges.push(child)\r\n        }\r\n      })\r\n      return a\r\n    }, {} as INumericKeyed<IGraphNode>)\r\n  }\r\n\r\n  private assignNodes () {\r\n    let next: number = 0\r\n    this.nodes = this.includes.reduce((a: Dictionary<number>, current: IInclude) => {\r\n      if (!a.containsKey(current.parent)) {\r\n        a.add(current.parent, next++)\r\n      }\r\n      current.children.forEach((c: string) => {\r\n        if (!a.containsKey(c)) {\r\n          a.add(c, next++)\r\n        }\r\n      })\r\n      return a\r\n    }, new Dictionary<number>())\r\n  }\r\n\r\n  private scanIncludes (file: string): Promise<string[]> {\r\n    return new Promise<string[]>((accept, reject) => {\r\n      const includes: string[] = []\r\n      const pass: fs.ReadStream = fs.createReadStream(path.join(this.root, file))\r\n      const saxStream: SAXStream = require('sax').createStream(true, {})\r\n      saxStream.on('opentag', (node) => {\r\n        const saxNode: ISaxNode = node\r\n        switch (saxNode.name) {\r\n          case 'xs:include': {\r\n            includes.push(saxNode.attributes.schemaLocation)\r\n            break\r\n          }\r\n        }\r\n      })\r\n      saxStream.on('ready', () => {\r\n        accept(includes)\r\n      })\r\n      saxStream.on('error', (r) => {\r\n        reject(r)\r\n      })\r\n      pass.pipe(saxStream)\r\n    })\r\n  }\r\n\r\n  private getIncludes (main: string): Promise<IInclude[]> {\r\n    const q: any[] = []\r\n    q.push([main])\r\n    const ordered: IInclude[] = []\r\n    const seen: Dictionary<boolean> = new Dictionary<boolean>()\r\n    return new Promise<IInclude[]>(async (accept, reject) => {\r\n      try {\r\n        while (q.length > 0) {\r\n          const batch: string[] = q.pop()\r\n          for (let next of batch) {\r\n            if (seen.containsKey(next)) {\r\n              continue\r\n            }\r\n            seen.add(next, true)\r\n            const includes: string[] = await this.scanIncludes(next)\r\n            ordered.push({\r\n              parent: next,\r\n              children: includes\r\n            } as IInclude)\r\n            q.push(includes)\r\n          }\r\n        }\r\n        accept(ordered)\r\n      } catch (e) {\r\n        reject(e)\r\n      }\r\n    })\r\n  }\r\n}\r\n"]}